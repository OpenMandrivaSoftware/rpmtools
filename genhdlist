#!/usr/bin/perl

(our $VERSION) = q$Id$ =~ /(\d+\.\d+)/;

use strict;
use URPM;
use URPM::Build;
use File::Find ();
use File::Path;
use Getopt::Long;
use Pod::Usage;
use File::Temp qw(tempdir);

my ($nooutput, $nobadrpm, $md5sum, $subdir, $suffix, $dest) = (0, 0, 0, "", "", "");
my $tmpdir_tpl = (-d "$ENV{HOME}/tmp" ? "$ENV{HOME}/tmp" : $ENV{TMPDIR} || "/tmp") . "/.build_hdlistXXXXX";

sub usage () {
    pod2usage({ -verbose => 1 });
}

GetOptions(
    'dest=s' => \$dest,
    'help|h' => sub { usage(); exit 0 },
    list => \my $list,
    nobadrpm => \$nobadrpm,
    noclean => \my $noclean,
    md5sum => \$md5sum,
    norecursive => \my $norecursive,
    s => \$nooutput,
    'subdir=s' => \$subdir,
    'suffix=s' => \$suffix,
    'v|version' => sub { warn "$0 version $VERSION\n"; exit 0 },
);

my $urpm = new URPM;
if ($subdir && $subdir !~ m{/$}) { $subdir .= '/' }
my $hdlist_base = "hdlist$suffix.cz";
my $hdlist = $subdir . $hdlist_base;
my $synthesis_base = "synthesis.$hdlist_base";
my $synthesis = $subdir . $synthesis_base;
my @dir = @ARGV ? @ARGV : (".");

grep { m!^/! } @dir and die "Directories to parse should be relative\n";

$dest and do { chdir $dest or die "Can't chdir in directory $dest\n" };

if ($subdir && !-e $subdir) {
    mkdir $subdir
	or die "Can't mkdir $subdir: $!n";
}
if ($subdir) {
    -d $subdir && -w _ && -x _
	or die "$subdir isn't a writable directory, bailing out\n";
}
my $tmpdir = tempdir($tmpdir_tpl, CLEANUP => !$noclean);

my @rpms;
my %rpmslist;

# get rpm list
my $listfh;
if ($list) {
    open $listfh, ">", "${subdir}list$suffix"
	or die "Can't create list file [${subdir}list$suffix]: $!\n";
}
foreach my $dir (@dir) {
    print "parsing $dir\n" unless $nooutput;
    @rpms = ();
    %rpmslist = ();
    File::Find::find(
	{
	    wanted => sub {
		next if $norecursive && $File::Find::dir ne $dir;
		if (/^.*\.rpm$/ && -f) {
		    push(@rpms, $File::Find::name);
		}
	    },
	    follow => 1,
	}, $dir,
    );
    $urpm->parse_rpms_build_headers(
	dir  => $tmpdir,
	rpms => \@rpms,
	dontdie => $nobadrpm,
	silent => $nooutput,
	callback => sub {
	    my ($urpm, $id, %options) = @_;
	    $rpmslist{scalar($urpm->{depslist}[$id]->fullname) . ".rpm"} = 1;
	    $urpm->{depslist}[$id]->pack_header;
	},
    );
    # This code will become useless... see above
    foreach my $rpm (@rpms) {
	$rpmslist{($rpm =~ m!.*/(.*)\z!)[0]} or next;
	print $listfh "$rpm\n" if $list;
    }
}
close $listfh if $listfh;

# create hdlist file
# No rpms, exit !
@{$urpm->{depslist}} or die "Nothing read, no file to write\n";

$urpm->build_hdlist(
    start  => 0,
    end    => $#{$urpm->{depslist}},
    dir    => $tmpdir,
    hdlist => $hdlist,
    ratio  => 9,
);

# create synthesis file
$urpm->build_synthesis(
    start     => 0,
    end       => $#{$urpm->{depslist}},
    synthesis => $synthesis,
);

if ($md5sum) {
    my $m = qx(cd '$subdir' && /usr/bin/md5sum '$hdlist_base' '$synthesis_base');
    open my $f, '>', "${subdir}MD5SUM" or die "Can't write MD5SUM: $!\n";
    print $f $m;
    close $f;
}

__END__

=head1 NAME

genhdlist - generates an hdlist and a synthesis file

=head1 SYNOPSIS

    genhdlist [options] dir [dir...]

=head1 OPTIONS

=over 4

=item --dest dir

Build indexes from this directory (that is, chdir's to this directory
before operation).

=item --list

Creates a list file.

=item --md5sum

Generates an MD5SUM file.

=item --nobadrpm

Do not abort on bad rpms.

=item --noclean

Keep cache files.

=item --norecursive

Do not recurse in subdirectories.

=item -s

Silent mode.

=item --subdir directory

Write indexes in this subdirectory.

=item --suffix SUFFIX

Put a suffix on list/hdlist/synthesis names (for example, C<_main>).

=back

=head1 DESCRIPTION

F<genhdlist> is used to generate an hdlist and an associated synthesis file
from a set of RPM packages found in the directories passed on the command-line.
By default it will put the hdlist and synthesis files in the current directory.

If the option B<--list> is given, it will also generate a F<list> file containing
the relative paths to all RPMs. Consequently, the paths to the directories
passed to F<genhdlist> must be relative ones.

=head1 SEE ALSO

gendistrib(1), parsehdlist(1)

=head1 COPYRIGHT

Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 MandrakeSoft SA

Copyright (C) 2005, 2006 Mandriva SA

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

=cut
