#!/usr/bin/perl

#- Copyright (C) 1999 MandrakeSoft (fpons@mandrakesoft.com)
#-
#- This program is free software; you can redistribute it and/or modify
#- it under the terms of the GNU General Public License as published by
#- the Free Software Foundation; either version 2, or (at your option)
#- any later version.
#-
#- This program is distributed in the hope that it will be useful,
#- but WITHOUT ANY WARRANTY; without even the implied warranty of
#- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#- GNU General Public License for more details.
#-
#- You should have received a copy of the GNU General Public License
#- along with this program; if not, write to the Free Software
#- Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use strict;
use URPM;
use URPM::Build;

my $urpm = new URPM;
my ($noclean, $nohdlists, $nobasefiles, @root, @hdlists) = 0;

($noclean,     @ARGV) = @ARGV if $ARGV[0] eq "--noclean";
(undef, @root, @ARGV) = @ARGV if $ARGV[0] eq "--distrib";

@root > 0 && @ARGV == 0 or die "usage: gendistrib [--noclean] --distrib <root distrib> <root_distrib2> ...\n";

my $root = $root[0];
my ($depslist, $provides, $compss, $hdlists) = ("$root/Mandrake/base/depslist.ordered",
						"$root/Mandrake/base/provides",
						"$root/Mandrake/base/compss",
						"$root/Mandrake/base/hdlists");

open F, $hdlists or die "unable to open $hdlists";
foreach (<F>) {
    chomp;
    s/\s*#.*$//;
    /^\s*$/ and next;
    m/^\s*(hdlist\S*\.cz2?)\s+(\S+)\s*(.*)$/ or die "invalid hdlist description \"$_\" in hdlists file";

    push @hdlists, { synthesis => "$root/Mandrake/base/synthesis.$1", hdlist => "$root/Mandrake/base/$1", dir => $2, descr => $3 };
}
close F;

my $headers_dir = ($ENV{TMPDIR} || "/tmp") . "/.build_hdlist";
sub clean_cache {
    system(($ENV{LD_LOADER} ? ($ENV{LD_LOADER}) : ()), "rm", "-rf", $headers_dir) unless $noclean;
}

clean_cache();

for (0..$#hdlists) {
    my $e = $hdlists[$_];

    #- try to find the right repository where can be found the directory
    #- listed in the hdlist file.
    #- if the number of root is equal the number of medium, assume a medium
    #- foreach root, else try to find a valid root containing the medium.
    if (scalar(@hdlists ) == scalar(@root)) {
	$root = $root[$_];
    } else {
	foreach (@root) {
	    -d "$_/$e->{dir}" and $root = $_, last;
	}
    }
    -d "$root/$e->{dir}" or die "unable to find a valid root directory which contains $e->{dir}\n";

    print STDERR "parsing rpm files in directory $root/$e->{dir}\n";
    my @headers = $urpm->parse_rpms_build_headers($headers_dir, glob("$root/$e->{dir}/*.rpm"));
    $e->{headers} = \@headers;
}

#- clean everything to start second pass.
print STDERR "clean data for second pass\n";
$urpm->unresolved_provides_clean;

for (0..$#hdlists) {
    my $e = $hdlists[$_];

    print STDERR "parsing headers for $e->{descr}\n";
    my ($start, $end) = $urpm->parse_headers($headers_dir, @{$e->{headers}});

    print STDERR "computing deps\n";
    $urpm->compute_deps;

    print STDERR "building hdlist for medium \"$e->{descr}\"\n";
    $urpm->build_hdlist($start, $end, $headers_dir, $e->{hdlist}, 9);

    print STDERR "building synthesis for medium \"$e->{descr}\n";
    $urpm->build_synthesis($start, $end, $e->{synthesis});
}

clean_cache();

print STDERR "building base files\n";
$urpm->build_base_files("$root/Mandrake/base/depslist.ordered",
			"$root/Mandrake/base/provides",
			"$root/Mandrake/base/compss");

