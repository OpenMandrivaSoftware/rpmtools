#!/usr/bin/perl

#- Copyright (C) 1999 MandrakeSoft (fpons@mandrakesoft.com)
#-
#- This program is free software; you can redistribute it and/or modify
#- it under the terms of the GNU General Public License as published by
#- the Free Software Foundation; either version 2, or (at your option)
#- any later version.
#-
#- This program is distributed in the hope that it will be useful,
#- but WITHOUT ANY WARRANTY; without even the implied warranty of
#- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#- GNU General Public License for more details.
#-
#- You should have received a copy of the GNU General Public License
#- along with this program; if not, write to the Free Software
#- Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use strict;
use URPM;
use URPM::Build;

my $urpm = new URPM;
my ($noclean, $nohdlists, $nobasefiles, @root, @hdlists) = (0, 0, 0);

($noclean,     @ARGV) = @ARGV if $ARGV[0] eq "--noclean";
(undef, @root, @ARGV) = @ARGV if $ARGV[0] eq "--distrib";

@root > 0 && @ARGV == 0 or die "usage: gendistrib [--noclean] --distrib <root distrib> <root_distrib2> ...\n";

my $root = $root[0];
my ($depslist, $provides, $compss, $hdlists) = ("$root/Mandrake/base/depslist.ordered",
						"$root/Mandrake/base/provides",
						"$root/Mandrake/base/compss",
						"$root/Mandrake/base/hdlists");

open F, $hdlists or die "unable to open $hdlists";
foreach (<F>) {
    chomp;
    s/\s*#.*$//;
    /^\s*$/ and next;
    m/^\s*(hdlist\S*\.cz2?)\s+(\S+)\s*(.*)$/ or die "invalid hdlist description \"$_\" in hdlists file";

    push @hdlists, { synthesis => "$root/Mandrake/base/synthesis.$1", hdlist => "$root/Mandrake/base/$1", dir => $2, descr => $3 };
}
close F;

my $headers_dir = ($ENV{TMPDIR} || "/tmp") . "/.build_hdlist";
sub clean_cache {
    system(($ENV{LD_LOADER} ? ($ENV{LD_LOADER}) : ()), "rm", "-rf", $headers_dir) unless $noclean;
}

clean_cache();

for (0..$#hdlists) {
    my $e = $hdlists[$_];
    my $r;

    #- try to find the right repository where can be found the directory
    #- listed in the hdlist file.
    #- if the number of root is equal the number of medium, assume a medium
    #- foreach root, else try to find a valid root containing the medium.
    if (scalar(@hdlists ) == scalar(@root)) {
	$r = $root[$_];
    } else {
	foreach (@root) {
	    -d "$_/$e->{dir}" and $r = $_, last;
	}
    }
    -d "$r/$e->{dir}" or die "unable to find a valid root directory which contains $e->{dir}\n";

    print STDERR "parsing rpm files in directory $r/$e->{dir}\n";
    my @headers = $urpm->parse_rpms_build_headers(dir  => $headers_dir,
						  rpms => [ glob("$r/$e->{dir}/*.rpm") ]);
    $e->{headers} = \@headers;
}

#- clean everything to start second pass.
print STDERR "clean data for second pass\n";
$urpm->unresolved_provides_clean;

for (0..$#hdlists) {
    my $e = $hdlists[$_];

    print STDERR "parsing headers for $e->{descr}\n";
    my ($start, $end) = $urpm->parse_headers(dir     => $headers_dir,
					     headers => $e->{headers});

    print STDERR "computing deps\n";
    $urpm->compute_deps;

    print STDERR "building hdlist for medium \"$e->{descr}\"\n";
    $urpm->build_hdlist(start  => $start,
			end    => $end,
			dir    => $headers_dir,
			hdlist => $e->{hdlist},
			ratio  => 9);

    print STDERR "building synthesis for medium \"$e->{descr}\n";
    $urpm->build_synthesis(start     => $start,
			   end       => $end,
			   synthesis => $e->{synthesis});
}

clean_cache();

print STDERR "building base files\n";
$urpm->build_base_files(depslist => "$root/Mandrake/base/depslist.ordered",
			provides => "$root/Mandrake/base/provides",
			compss   => "$root/Mandrake/base/compss");

#- check if there are NOTFOUND in dependancy, check if they are in other medium, warn the user.
foreach (0 .. $#{$urpm->{depslist}}) {
    my $pkg = $urpm->{depslist}[$_];

    foreach (split " ", $urpm->{deps}[$_]) {
	/NOTFOUND_(.*)/ or next;
	print STDERR $pkg->fullname . " requires [$1] which\n";
	if ($urpm->{provides}{$1}) {
	    print STDERR "  is available on packages not listed in this medium or previous medium:\n";
	    foreach (keys %{$urpm->{provides}{$1}}) {
		my $dep_pkg = $urpm->{depslist}[$_];
		print STDERR "    " . $dep_pkg->fullname . "\n";
	    }
	} else {
	    print STDERR "  is not available in any medium listed\n";
	    if (/NOTFOUND_(\D*)(\d+[\.\-\d]*)?(.*)?\.so\./) {
		my $re = (quotemeta $1) . '(\d+[\.\-\d]*)' . (!$2 && "?") . '\.so\.';
		foreach (keys %{$urpm->{provides}}) {
		    /$re/ or next;
		    print STDERR "  but a similar provides is available as [$_], need rebuild ?\n";
		}
	    }
	}
    }
}
